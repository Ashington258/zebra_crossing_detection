# opencv 检测斑马线



基于 openCV 设计一个程序由于识别斑马线，流程如下，每进行一步图像处理后显示处理过的图像展示效果

1. ROI 区域提取
   1. 首先裁剪去除图上上半 30%区域
   2. 灰度化
   3. 平滑滤波
   4. 高斯模糊
   5. canny 边缘提取轮廓
   6. 形态学操作，侵蚀和膨胀让斑马线轮廓闭合
   7. 过滤掉面积小得闭合区域，消除噪点
   8. 提取闭合轮廓区域作为 ROI，创造 mask 去除以外的其他区域
2. canny 边缘检测
3. hough 变化检测直线
4. 统计直线数量超过阈值则认为识别到斑马线（bool函数，识别到返回True）

## 总结类

1. [x] 传统算法
   1. [ ] 基于阈值
   2. [x] 基于区域提取
      1. [ ] 基于阈值和形态学操作的组合
         1. [ ] 彩色空间
         2. [ ] 灰度空间
      2. [x] 基于边缘和形态学操作的组合
   3. [ ] 基于边缘检测
2. [ ] 分割方法
   1. [ ] 概率图模型
   2. [ ] 像素，超像素分类

像素或者图像域之上的条件随机场，传统方法还是依靠图像的一些浅层信息，而仅仅依靠浅层信息往往难以达到精细分割的要求

基于 OpenCV 设计一个程序用于识别斑马线的过程如下。每一步输出处理的图像结果，以方便调试参数。我们将逐步实现并展示每个步骤的输出图像。

## 代码

### 1. ROI 区域提取

#### 1.1 裁剪去除图像上半 30% 区域

首先加载图像并裁剪上半部分。

```python
import cv2
import numpy as np
from matplotlib import pyplot as plt

# 读取图像
image = cv2.imread('zebra_crossing.jpg')

# 获取图像尺寸
height, width = image.shape[:2]

# 裁剪去除图像上半 30% 区域
cropped_image = image[int(height*0.3):, :]

# 显示裁剪后的图像
plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
plt.title('Cropped Image')
plt.show()
```

#### 1.2 平滑滤波

应用平滑滤波减少噪声。

```python
smoothed_image = cv2.bilateralFilter(cropped_image, 9, 75, 75)

# 显示平滑后的图像
plt.imshow(cv2.cvtColor(smoothed_image, cv2.COLOR_BGR2RGB))
plt.title('Smoothed Image')
plt.show()
```

#### 1.3 高斯模糊

应用高斯模糊进一步减少噪声。

```python
gaussian_blurred_image = cv2.GaussianBlur(smoothed_image, (5, 5), 0)

# 显示高斯模糊后的图像
plt.imshow(cv2.cvtColor(gaussian_blurred_image, cv2.COLOR_BGR2RGB))
plt.title('Gaussian Blurred Image')
plt.show()
```

#### 1.4 Canny 边缘提取轮廓

使用 Canny 边缘检测。

```python
edges = cv2.Canny(gaussian_blurred_image, 50, 150)

# 显示 Canny 边缘检测后的图像
plt.imshow(edges, cmap='gray')
plt.title('Canny Edges')
plt.show()
```

#### 1.5 形态学操作（侵蚀和膨胀）

进行形态学操作使边缘闭合。

```python
kernel = np.ones((5, 5), np.uint8)
morph_image = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

# 显示形态学操作后的图像
plt.imshow(morph_image, cmap='gray')
plt.title('Morphology Operation')
plt.show()
```

#### 1.6 提取闭合轮廓区域作为 ROI，创建 mask 去除以外的其他区域

提取闭合轮廓并创建 mask。

```python
contours, _ = cv2.findContours(morph_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
mask = np.zeros_like(morph_image)

# 假设斑马线是最大的闭合区域之一
cv2.drawContours(mask, contours, -1, 255, thickness=cv2.FILLED)

# 应用 mask
roi_image = cv2.bitwise_and(cropped_image, cropped_image, mask=mask)

# 显示提取的 ROI 区域
plt.imshow(cv2.cvtColor(roi_image, cv2.COLOR_BGR2RGB))
plt.title('ROI Image')
plt.show()
```

### 2. 灰度化

将图像转换为灰度图。

```python
gray_image = cv2.cvtColor(roi_image, cv2.COLOR_BGR2GRAY)

# 显示灰度图像
plt.imshow(gray_image, cmap='gray')
plt.title('Grayscale Image')
plt.show()
```

### 3. Canny 边缘检测

在灰度图像上应用 Canny 边缘检测。

```python
edges_gray = cv2.Canny(gray_image, 50, 150)

# 显示灰度图像上的 Canny 边缘检测结果
plt.imshow(edges_gray, cmap='gray')
plt.title('Canny Edges on Grayscale Image')
plt.show()
```

### 4. Hough 变化检测直线

使用 Hough 变换检测直线。

```python
lines = cv2.HoughLinesP(edges_gray, 1, np.pi / 180, threshold=100, minLineLength=50, maxLineGap=10)

# 绘制检测到的直线
line_image = np.copy(roi_image)
if lines is not None:
    for line in lines:
        x1, y1, x2, y2 = line[0]
        cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 2)

# 显示检测到直线后的图像
plt.imshow(cv2.cvtColor(line_image, cv2.COLOR_BGR2RGB))
plt.title('Detected Lines')
plt.show()
```

### 5. 统计直线数量超过阈值则认为识别到斑马线

根据检测到的直线数量判断是否识别到斑马线。

```python
# 设置阈值
threshold = 10

# 统计检测到的直线数量
line_count = len(lines) if lines is not None else 0

# 判断是否识别到斑马线
if line_count > threshold:
    print("斑马线已识别")
else:
    print("未识别到斑马线")
```

完整代码如下：

```python
import cv2
import numpy as np
from matplotlib import pyplot as plt

# 读取图像
image = cv2.imread('zebra_crossing.jpg')

# 获取图像尺寸
height, width = image.shape[:2]

# 裁剪去除图像上半 30% 区域
cropped_image = image[int(height*0.3):, :]

# 平滑滤波
smoothed_image = cv2.bilateralFilter(cropped_image, 9, 75, 75)

# 高斯模糊
gaussian_blurred_image = cv2.GaussianBlur(smoothed_image, (5, 5), 0)

# Canny 边缘检测
edges = cv2.Canny(gaussian_blurred_image, 50, 150)

# 形态学操作
kernel = np.ones((5, 5), np.uint8)
morph_image = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

# 提取闭合轮廓
contours, _ = cv2.findContours(morph_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
mask = np.zeros_like(morph_image)
cv2.drawContours(mask, contours, -1, 255, thickness=cv2.FILLED)

# 应用 mask
roi_image = cv2.bitwise_and(cropped_image, cropped_image, mask=mask)

# 灰度化
gray_image = cv2.cvtColor(roi_image, cv2.COLOR_BGR2GRAY)

# 灰度图像上的 Canny 边缘检测
edges_gray = cv2.Canny(gray_image, 50, 150)

# Hough 变化检测直线
lines = cv2.HoughLinesP(edges_gray, 1, np.pi / 180, threshold=100, minLineLength=50, maxLineGap=10)

# 绘制检测到的直线
line_image = np.copy(roi_image)
if lines is not None:
    for line in lines:
        x1, y1, x2, y2 = line[0]
        cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 2)

# 显示检测到直线后的图像
plt.imshow(cv2.cvtColor(line_image, cv2.COLOR_BGR2RGB))
plt.title('Detected Lines')
plt.show()

# 统计直线数量超过阈值则认为识别到斑马线
threshold = 10
line_count = len(lines) if lines is not None else 0

if line_count > threshold:
    print("斑马线已识别")
else:
    print("未识别到斑马线")
```

该代码将图像从加载、处理到输出每一步的结果，帮助调试和优化参数，以便准确识别斑马线。
