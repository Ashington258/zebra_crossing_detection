我先在有两个py文件需要同时运行zebra_crossing_detection.py和red_light_detection.py，应该怎么做？

工程结构：
📦zebra_crossing_detection
 ┣ 📂doc
 ┃ ┣ 📂斑马线流程
 ┃ ┃ ┣ 📜代码流程.ipynb
 ┃ ┃ ┗ 📜整体流程.md
 ┃ ┣ 📂红绿灯流程
 ┃ ┃ ┗ 📜流程.md
 ┃ ┗ 📂论文资料
 ┃ ┃ ┣ 📂OpenCV
 ┃ ┃ ┃ ┣ 📜斑马线智能分割及行人位置自动判别方法研究_李平原.pdf
 ┃ ┃ ┃ ┗ 📜车载激光点云斑马线提取方法研究_王耀.pdf
 ┃ ┃ ┗ 📂人工智能
 ┃ ┃ ┃ ┣ 📜基于改进SegNet模型的斑马线检测方法研究_付阳阳.pdf
 ┃ ┃ ┃ ┗ 📜基于深度学习的道路斑马线与行人运动检测算法研究与应用_付阳阳.pdf
 ┣ 📂image
 ┃ ┣ 📜1.png
 ┃ ┣ 📜1_gray.png
 ┃ ┣ 📜2.png
 ┃ ┣ 📜3.png
 ┃ ┣ 📜fe9ee2fae4d6cc95f3bce01334d1016.jpg
 ┃ ┗ 📜RED_LIGHT.png
 ┣ 📂Parameter_adjustment_assistant
 ┃ ┣ 📜redlight_debug.py
 ┃ ┗ 📜zebra_debug.py
 ┣ 📂test
 ┃ ┣ 📜camera_test.py
 ┃ ┣ 📜canny_debug.py
 ┃ ┣ 📜Grayscale_threshold_debug.py
 ┃ ┗ 📜HSV_debug.py
 ┣ 📂traffic_detection
 ┃ ┗ 📜red_light_detection.py
 ┣ 📂zebra_detection
 ┃ ┗ 📜zebra_crossing_detection.py
 ┗ 📜.gitignore


## 代码：

### 1 ebra_crossing_detection.py：

```python
import cv2
import numpy as np

def on_trackbar_change(val):
    pass

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def zebra_crossing_detection():
    cap = cv2.VideoCapture(0)  # 使用摄像头
    if not cap.isOpened():
        print("Error: Unable to open camera.")
        return
    
    # 创建窗口和滑动条
    steps = ['1. Cropped Image', '2. Gray Image', '3. Median Blurred Image', '4. Gaussian Blurred Image', 
             '5. Canny Edges', '6. Morphologically Closed Edges', '7. Mask with Contours', 
             '8. ROI Image', '9. ROI Canny Edges', '10. Detected Lines']
    
    for step in steps:
        cv2.namedWindow(step)

    cv2.createTrackbar('Crop %', '1. Cropped Image', 30, 100, on_trackbar_change)
    cv2.createTrackbar('Median Blur', '3. Median Blurred Image', 15, 20, on_trackbar_change)
    cv2.createTrackbar('Gaussian Blur', '4. Gaussian Blurred Image', 0, 15, on_trackbar_change)
    cv2.createTrackbar('Canny Threshold 1', '5. Canny Edges', 50, 200, on_trackbar_change)
    cv2.createTrackbar('Canny Threshold 2', '5. Canny Edges', 134, 300, on_trackbar_change)
    cv2.createTrackbar('Morph Kernel', '6. Morphologically Closed Edges', 1, 20, on_trackbar_change)
    cv2.createTrackbar('Area Threshold', '6. Morphologically Closed Edges', 3000, 5000, on_trackbar_change)
    cv2.createTrackbar('Hough Threshold', '10. Detected Lines', 16, 200, on_trackbar_change)
    cv2.createTrackbar('Line Threshold', '10. Detected Lines', 10, 50, on_trackbar_change)

    while True:
        ret, frame = cap.read()  # 从摄像头读取帧
        if not ret:
            print("Error: Unable to capture frame.")
            break

        # 获取滑动条的值
        crop_percent = cv2.getTrackbarPos('Crop %', '1. Cropped Image') / 100.0
        median_blur_val = ensure_odd(cv2.getTrackbarPos('Median Blur', '3. Median Blurred Image'))
        gaussian_blur_val = ensure_odd(cv2.getTrackbarPos('Gaussian Blur', '4. Gaussian Blurred Image'))
        canny_threshold1 = cv2.getTrackbarPos('Canny Threshold 1', '5. Canny Edges')
        canny_threshold2 = cv2.getTrackbarPos('Canny Threshold 2', '5. Canny Edges')
        morph_kernel_size = cv2.getTrackbarPos('Morph Kernel', '6. Morphologically Closed Edges')
        area_threshold = cv2.getTrackbarPos('Area Threshold', '6. Morphologically Closed Edges')
        hough_threshold = cv2.getTrackbarPos('Hough Threshold', '10. Detected Lines')
        line_threshold = cv2.getTrackbarPos('Line Threshold', '10. Detected Lines')

        # 处理图像
        height = frame.shape[0]
        cropped_image = frame[int(crop_percent * height):, :]
        cv2.imshow('1. Cropped Image', cropped_image)
        
        gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)
        cv2.imshow('2. Gray Image', gray)
        
        # 应用中值滤波
        if median_blur_val > 1:
            blurred = cv2.medianBlur(gray, median_blur_val)
        else:
            blurred = gray
        cv2.imshow('3. Median Blurred Image', blurred)
        
        # 应用高斯模糊
        if gaussian_blur_val > 1:
            gaussian_blurred = cv2.GaussianBlur(blurred, (gaussian_blur_val, gaussian_blur_val), 0)
        else:
            gaussian_blurred = blurred
        cv2.imshow('4. Gaussian Blurred Image', gaussian_blurred)
        
        edges = cv2.Canny(gaussian_blurred, canny_threshold1, canny_threshold2)
        cv2.imshow('5. Canny Edges', edges)
        
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        closed_edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
        cv2.imshow('6. Morphologically Closed Edges', closed_edges)
        
        contours, _ = cv2.findContours(closed_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        mask = np.zeros_like(closed_edges)
        for contour in contours:
            if cv2.contourArea(contour) > area_threshold:
                cv2.drawContours(mask, [contour], -1, (255), thickness=cv2.FILLED)
        cv2.imshow('7. Mask with Contours', mask)
        
        roi = cv2.bitwise_and(cropped_image, cropped_image, mask=mask)
        cv2.imshow('8. ROI Image', roi)
        
        roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        roi_edges = cv2.Canny(roi_gray, canny_threshold1, canny_threshold2)
        cv2.imshow('9. ROI Canny Edges', roi_edges)
        
        lines = cv2.HoughLinesP(roi_edges, 1, np.pi / 180, threshold=hough_threshold, minLineLength=50, maxLineGap=10)
        
        line_image = np.copy(cropped_image)
        if lines is not None:
            for line in lines:
                for x1, y1, x2, y2 in line:
                    cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.imshow('10. Detected Lines', line_image)
        
        detected = lines is not None and len(lines) > line_threshold
        
        if cv2.waitKey(1) & 0xFF == 27:  # 按下 'Esc' 键退出
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# 调用函数进行测试
detected = zebra_crossing_detection()
print("Zebra Crossing Detected: ", detected)
```

### 2 red_light_detection.py：

```python
import cv2
import numpy as np

def on_trackbar_change(val):
    pass

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def red_light_detection():
    # 打开摄像头
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Cannot open camera")
        return
    
    # 创建窗口和滑动条
    steps = [
        '1. Original Image', '2. Smooth Image', '3. Gaussian Blurred Image', 
        '4. HSV Red Mask', '5. Morphological Transform', '6. Contours and Red Light'
    ]
    
    for step in steps:
        cv2.namedWindow(step)

    cv2.createTrackbar('Smooth Kernel', '2. Smooth Image', 20, 30, on_trackbar_change)
    cv2.createTrackbar('Gaussian Blur', '3. Gaussian Blurred Image', 10, 50, on_trackbar_change)
    cv2.createTrackbar('Lower Hue', '4. HSV Red Mask', 0, 180, on_trackbar_change)
    cv2.createTrackbar('Upper Hue', '4. HSV Red Mask', 10, 180, on_trackbar_change)
    cv2.createTrackbar('Lower Saturation', '4. HSV Red Mask', 100, 255, on_trackbar_change)
    cv2.createTrackbar('Upper Saturation', '4. HSV Red Mask', 255, 255, on_trackbar_change)
    cv2.createTrackbar('Lower Value', '4. HSV Red Mask', 100, 255, on_trackbar_change)
    cv2.createTrackbar('Upper Value', '4. HSV Red Mask', 255, 255, on_trackbar_change)
    cv2.createTrackbar('Erode/Dilate Kernel', '5. Morphological Transform', 3, 20, on_trackbar_change)
    cv2.createTrackbar('Min Area', '6. Contours and Red Light', 400, 5000, on_trackbar_change)
    cv2.createTrackbar('Max Area', '6. Contours and Red Light', 3000, 5000, on_trackbar_change)

    while True:
        # 从摄像头捕获一帧
        ret, original_image = cap.read()
        if not ret:
            print("Failed to grab frame")
            break
        
        # 获取滑动条的值
        smooth_kernel_size = ensure_odd(cv2.getTrackbarPos('Smooth Kernel', '2. Smooth Image'))
        gaussian_blur_val = ensure_odd(cv2.getTrackbarPos('Gaussian Blur', '3. Gaussian Blurred Image'))
        lower_hue = cv2.getTrackbarPos('Lower Hue', '4. HSV Red Mask')
        upper_hue = cv2.getTrackbarPos('Upper Hue', '4. HSV Red Mask')
        lower_saturation = cv2.getTrackbarPos('Lower Saturation', '4. HSV Red Mask')
        upper_saturation = cv2.getTrackbarPos('Upper Saturation', '4. HSV Red Mask')
        lower_value = cv2.getTrackbarPos('Lower Value', '4. HSV Red Mask')
        upper_value = cv2.getTrackbarPos('Upper Value', '4. HSV Red Mask')
        morph_kernel_size = ensure_odd(cv2.getTrackbarPos('Erode/Dilate Kernel', '5. Morphological Transform'))
        min_area = cv2.getTrackbarPos('Min Area', '6. Contours and Red Light')
        max_area = cv2.getTrackbarPos('Max Area', '6. Contours and Red Light')

        # 显示原始图像
        cv2.imshow('1. Original Image', original_image)

        # 平滑滤波
        smooth = cv2.medianBlur(original_image, smooth_kernel_size)
        cv2.imshow('2. Smooth Image', smooth)
        
        # 高斯模糊
        gaussian_blurred = cv2.GaussianBlur(smooth, (gaussian_blur_val, gaussian_blur_val), 0)
        cv2.imshow('3. Gaussian Blurred Image', gaussian_blurred)
        
        # 转换到 HSV 色彩空间
        hsv = cv2.cvtColor(gaussian_blurred, cv2.COLOR_BGR2HSV)
        
        # 提取红色区域
        lower_red = np.array([lower_hue, lower_saturation, lower_value])
        upper_red = np.array([upper_hue, upper_saturation, upper_value])
        mask = cv2.inRange(hsv, lower_red, upper_red)
        cv2.imshow('4. HSV Red Mask', mask)
        
        # 形态学操作，侵蚀和膨胀让红灯轮廓闭合
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        morph = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        cv2.imshow('5. Morphological Transform', morph)
        
        # 查找轮廓该方法计算出包含轮廓的最小外接圆，然后比较圆的半径和轮廓的面积。这样可以更精确地判断轮廓是否近似为圆形。
        contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        detected = False
        output_image = original_image.copy()
        for contour in contours:
            area = cv2.contourArea(contour)
            if min_area < area < max_area:
                (x, y), radius = cv2.minEnclosingCircle(contour)
                center = (int(x), int(y))
                radius = int(radius)
                circle_area = np.pi * (radius ** 2)
                
                if min_area < circle_area < max_area:
                    cv2.circle(output_image, center, radius, (0, 255, 0), 2)
                    detected = True
        
        cv2.imshow('6. Contours and Red Light', output_image)
        
        if cv2.waitKey(1) & 0xFF == 27:  # 按下 'Esc' 键退出
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# 调用函数进行测试
detected = red_light_detection()
print("Red Light Detected: ", detected)

```